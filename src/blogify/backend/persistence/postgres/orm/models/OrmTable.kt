package blogify.backend.persistence.postgres.orm.models

import blogify.backend.resources.models.Resource
import com.andreapivetta.kolor.red

import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Table

import java.util.UUID

import kotlin.reflect.KClass

/**
 * Table generated by the ORM
 *
 * @property klass    the [KClass] the table was generated for
 * @property mappings the [mappings][PropertyMapping] to use for building the table
 *
 * @author Benjozork
 */
class OrmTable<TResource : Resource> (
    val klass: KClass<TResource>,
    val mappings: Set<PropertyMapping>
) : SimpleOrmTable(name = klass.simpleName ?: error("klass must not be an anonymous object literal")) {

    override var primaryKey: PrimaryKey? = null

    val dependencyTables = mutableSetOf<Table>()

    val columnMappings = mappings
        .filter { it !is PropertyMapping.AssociativeMapping<*> && it !is PropertyMapping.PrimitiveAssociativeMapping<*> }
        .associateWith { it.applyMappingToTable(this) }

    /**
     * Contains the columns that serves as the identifier (a UUID) for the entity stored in this table. This should always be the only
     * mapping of type [PropertyMapping.IdentifierMapping].
     */
    @Suppress("UNCHECKED_CAST")
    val identifyingColumn: Column<UUID>
        get() = columnMappings.entries.firstOrNull { it.key is PropertyMapping.IdentifierMapping }?.let { it.value as Column<UUID> }
            ?: error("fatal: no identifying column in table '${this.tableName}'".red())

    /**
     * Check the mapping status of the table
     *
     * @return whether or not the table is fully mapped (in other words, whether or not there are still [PropertyMapping.AssociativeMapping] mappings
     *         to complete)
     */
    fun fullyMapped() = this.columnMappings.keys
        .filterIsInstance<PropertyMapping.AssociativeMapping<*>>()
        .any { it.complete }

    /**
     * @return the remaining [PropertyMapping.AssociativeMapping] mappings in the table
     */
    fun remainingAssociativeMappings() = this.mappings
        .filterIsInstance<PropertyMapping.AssociativeMapping<*>>()
        .filter { !it.complete }

    /**
     * @return the remaining [PropertyMapping.AssociativeMapping] mappings in the table
     */
    fun remainingPrimitiveAssociativeMappings() = this.mappings
        .filterIsInstance<PropertyMapping.PrimitiveAssociativeMapping<*>>()
        .filter { !it.complete }

}
