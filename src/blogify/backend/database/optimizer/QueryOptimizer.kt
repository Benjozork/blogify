package blogify.backend.database.optimizer

import blogify.reflect.extensions.okHandle
import blogify.reflect.extensions.safeKlass
import blogify.backend.annotations.table
import blogify.backend.database.binding.SqlBinding
import blogify.backend.database.handling.query
import blogify.backend.database.models.QueryContext
import blogify.backend.util.*
import blogify.reflect.MappedData
import blogify.reflect.entity.Entity
import blogify.reflect.extensions.klass

import org.jetbrains.exposed.sql.*

import com.github.kittinunf.result.coroutines.mapError
import com.github.kittinunf.result.coroutines.SuspendableResult

import kotlin.reflect.KClass

import java.util.*

/**
 * Takes care of generating optimized, broad queries for fetching all data needed to instantiate
 * one of more resources.
 *
 * @author Benjozork
 */
object QueryOptimizer {

    private val classJoinCache = MapCache<KClass<out Entity>, ColumnSet>()

    fun <TResource : Entity> optimize(klass: KClass<TResource>, condition: SqlExpressionBuilder.() -> Op<Boolean>): Query {
        val mainJoin = classJoinCache.findOr(klass) { makeJoinForClass(klass) }
            .assertGet()

        return mainJoin.select(condition)
    }

    private object NullValue : Exception("no error - null value for SingleRef - this should not be thrown")

    /**
     * Takes a list of [result row][ResultRow] from a query of a [Join] generated by [optimize] and transforms it into a list of instances
     * of [TResource] using the data in the row.
     *
     * This takes care of feeding the columns to the convert() functions of the [tables][blogify.backend.database.models.ResourceTable] for
     * the classes of the different properties of [TResource], and of running additional queries for [x-to-many references][SqlBinding.ReferenceToMany] if needed.
     *
     * @param queryContext the [QueryContext] for caching
     * @param klass          the class associated with [TResource], used for reflection purposes
     * @param rows           a set of [result rows][ResultRow], each to be converted to instances of [TResource]
     */
    suspend fun <TResource : Entity> convertOptimizedRows (
        queryContext: QueryContext,
        klass: KClass<TResource>,
        rows: List<ResultRow>
    ): List<TResource> {
        return rows.map { row ->
            val bindingsData: MappedData = klass.table.bindings.map { binding ->
                binding.property.okHandle!! to Wrap {
                    when (binding) {
                        is SqlBinding.Reference<*, *>,
                        is SqlBinding.NullableReference<*, *> ->
                            resolveSingleRefInstance(queryContext, binding, row)
                                .get()
                        is SqlBinding.ReferenceToMany<*, *> -> {
                            resolveManyRefItems(queryContext, binding, row[binding.table.uuid])
                                .get()
                        }
                        is SqlBinding.HasColumn<*> -> // Get the data directly from the row
                            row[binding.column]!!
                        else -> never
                    }
                }.mapError { exception ->
                    if (exception is NullValue)
                        return@mapError exception
                    else IllegalStateException("error occurred during optimized row processing for property '${binding.property.name}' " +
                            "- ${exception::class.simpleName}", exception)
                }
            }.toMap().mapValues { (_, result) ->
                when (result) {
                    is SuspendableResult.Success<*, *> -> result.value
                    is SuspendableResult.Failure<*, *> ->
                        if (result.getException() is NullValue)
                            null
                        else throw result.getException()
                }
            }

            with(queryContext) {
                klass.construct(bindingsData).get() // Finally, construct the class
            }
        }
    }

    private suspend fun resolveSingleRefInstance (
        queryContext: QueryContext,
        binding: SqlBinding<*, *, *>,
        row: ResultRow
    ): Sr<Entity> {
        val bindingRightTable = binding.property.returnType.safeKlass<Entity>()?.table ?: never
        val rightTableAlias = bindingRightTable.alias("${binding.property.klass.simpleName}->${binding.property.name}")

        // If row[bindingRightTable.uuid] is null, the item is null, so we should return a failure accordingly
        if (binding is SqlBinding.NullableReference)
            letCatchingOrNull {
                row[rightTableAlias[bindingRightTable.uuid]]
            } ?: return Sr.error(NullValue)

        // Call convert() on the property's table with the row; it contains its data too
        return bindingRightTable.convert (
            queryContext = queryContext,
            source = row,
            aliasToUse = bindingRightTable.alias("${binding.property.klass.simpleName}->${binding.property.name}")
        )
    }

    private suspend fun resolveManyRefItems (
        request: QueryContext,
        binding: SqlBinding.ReferenceToMany<*, *>,
        withId: UUID
    ): SrList<Any> = query { // Run a query to select the ManyRef items
        binding.otherTable.select { binding.otherTableFkToPkCol eq withId }
            .toSet().map { row -> binding.conversionFunction(row) }
    }

}
